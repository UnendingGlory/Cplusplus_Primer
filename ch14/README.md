#### Chapter 14 重载运算与类型转换
1. 对于一个运算符函数来说，它要么是类的成员，要么至少有一个类类型的参数
2. 对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致
3. 当设计一个类的时候，重载运算符**应该尽量设计的和内置类型一致**
4. 重载运算符的返回类型通常情况下应该和内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符(+=这种）应该返回左侧运算对象的一个引用。
5. 运算符重载为成员还是非成员？
如果定义成**成员函数**，则其**左侧对象**必须是**运算符所属类的一个对象**。

具有对称性的运算符可能转换成任意一端的运算对象，例如算术、相等、关系和**位运算符**等，因此他们通常定义成非成员函数（例如我们能求一个double和一个int的和，而且他们中的任何一个都可以是左侧或者右侧运算对象）
6. 重载输出运算符尽量减少格式化操作（尤其是输出换行符）🎶
7. 重载的输入输出运算符必须是非成员函数，否则他们的左侧对象将是我们类的一个对象，就和iostream标准库不兼容了（cout << ...)

所以IO运算符一般被定义为友元

输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

8. 通常情况下算术和关系运算符定义成非成员函数以允许对左侧或右侧对象进行转换。

关系运算符一般不改变运算对象的状态，所以形参都是对象的常量引用。

9. 相等和不相等运算符中的一个该把工作委托给另一个，而另一个运算符只是调用那个真正工作的运算符（关系运算符某种意义上也一样，比如>和<=，只要逻辑上严格对立即可）
```C++
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn() && lhs.units_sold == rhs.units_sold &&
        lhs.revenue == rhs.revenue;
}

// 不相等运算符取反即可
bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
    return !(lhs === rhs);
}
```

10. 重载关系运算符：因为关联容器（map，set）和一些算法要用到小于运算符，所以定义operator <会比较有用

不是所有的类都有逻辑意义上的<，有的类不需要定义这种关系（对于他们是无意义的）

11. 重载下标运算符：(二元运算符，一般是类的成员函数）

通常下标运算符以所访问元素的引用作为返回。

但是**最好同时定义下标运算符的常量版本和非常量版本**，当作用于一个常量对象时，下标运算符返回常量引用以确保不会给返回的对象赋值。

```C++
class StrVec:{
public:
    std::string& operator[](std::size_t n) { return elements[n]; }
    const std::string& operator[](std::size_t n) const {return elements[n]; }
private:
    std::string *elements;
}

StrVec svec;
const StrVec cvec = svec;
svec[0] = "zero"; // 正确
cvec[0] = "zip"; // 错误，因为对cvec取下标返回的是常量引用
```

12. 重载前置和后置运算符

需要注意前置和后置运算符对应的功能。

且为了区分前置和后置运算符，后置版本接受一个额外的（不会被使用的）int类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。**这个形参的唯一作用就是区分前置和后置版本的重载函数。**

```C++
class StrBlobPtr
{
public:
    StrBlobPtr& operator++(); // 前置递增运算符
    StrBlobPtr operator++(int); // 后置递增运算符
    StrBlobPtr& operator--(); // 前置递减运算符
    StrBlobPtr operator--(int); //后置递减运算符
};
```
前置版本返回对象的印象，而后置运算符应该返回对象的原值（递增或递减之前）

对于后置版本来说，一般在递增对象之前要记录对象的状态

13. 成员访问运算符\*和->重载时，由于两者功能类似，所以也可以将一个的功能委托给另一个。

14. 函数调用运算符()重载
如果类重载了函数调用运算符，则我们可以像**使用函数**一样**使用该类的对象**
```C++
struct absInt{
    int operator()(int val) const
    {
        return val <0 ? -val : val;
    }
};

int i = -42;
absInt absObj;
int ui = absObs(i);
```

如果类定义了调用运算符，则该类的对象称作函数对象。函数对象常常被作为泛型算法的实参。

labmda函数其实就是一个函数对象，当我们编写一个lambda后，编译器将表达式翻译成一个**未命名类的未命名对象**，而捕获类型就是对应的数据成员和构造函数参数。

15. 标准库就定义了多种函数对象，这些函数对象都是以模板的形式给出

如老朋友greater<Type>, less<Type>

```C++
// greater<int>是个模板，()生成了一个对象，作为参数即是对象函数
priority_queue<int, vector<int>, greater<int>()> pq;

sort(svec.begin(), svec.end(), greater<string>()>;
```

16. 可调用对象

C++中可调用对象：**函数、函数指针、labmda表达式、重载了调用运算符的类**、bind创建的对象

17. 重载类型转换运算符

类型转换运算符是隐式执行的，所以无法给这些函数传递实参，所以定义时不能定义任何形参，同样，类型转换运算函数不负责指定返回类型。

典型例子：
```C++
while(std::cin >> value);
```
std::cin读入一个value后返回的是一个ostream &对象，在ostream类中重载了bool类型的类型转换运算符，所以返回后的ostream对象自动隐式转换成了bool，bool的值由cin的条件状态而定）

但是在实践中，类很少提供类型转换运算符。

如果要关闭自动的类型转换，则定义成explicit即可，那就必须要显式强制转换（但是在循环判断以及一些表达式中可能还是会发生隐式转换）

```C++
class smallInt{
public:
    explicit operator int() const {return val;}
};
SmallInt si = 3;
si + 3; // error，因为此处需要隐式的类型转换，但类的运算符是显式的
static_cast<int>(si) + 3; // 正确，显式转换
```

18. 在使用类型转换时，要尽量避免二义性，如果一个类A构造函数参数是类B，又重载了类B的类型转换运算符，则会出现二义性问题

想要正确设计类的重载运算符、转换构造函数以及类型转换函数，必须倍加小心

19. 函数表：形如map或者vector的容器，容器中所存的值可以被调用（可调用对象）