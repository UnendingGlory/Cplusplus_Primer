#### Chapter 13 拷贝控制
1. 拷贝构造函数：第一个参数必须是自身的引用（一般为const的），且**任何额外参数都有默认值**

@Question: 为什么一定要是自身的引用？

因为拷贝构造函数用来初始化非引用类型对象，所以如果参数不是引用类型，则拷贝构造函数会无限调用自身

2. 拷贝类会调用拷贝构造函数，内置类型的成员则直接拷贝。
3. 拷贝初始化场合：
* 用=定义自定类
* 将一个对象作为实参传递给一个非引用类型的形参
* 从一个返回类型为非引用类型的函数返回一个对象
* 用花括号列表初始化一个聚合类中（全是public且没有构造函数且没有类内初始值）的成员
3. 标准库用insert或者push成员时是拷贝初始化，而用emplace创建的元素进行直接初始化

4. 调用指针对象的析构函数不会删除其指向的对象

5. 一般拷贝函数/拷贝移动函数等合成的default都是inline的
编译器在必要的时候会绕过拷贝构造函数，改成直接构造

注意：X a = b; 调用的是拷贝构造函数； a = b；调用的才是赋值运算符

6. 如果类重载了赋值运算符=，则赋值运算符通常返回一个指向左侧运算对象的引用(一般是return \*this)💊

**如果类没有定义拷贝赋值运算符，一般编译器会自动合成一个**

编写赋值运算符时，通常需要记住两点：
* 如果将一个对象赋予它**自身**，赋值运算符必须能够正确工作
* 大多数赋值运算符组合了析构函数和拷贝构造函数的工作

7. 智能指针是类类型，所以具有析构函数

8. 调用析构函数的时机：
* 变量在离开作用域时
* 对象被销毁时
* 创建临时对象的完整表达式结束时

9. 如果一个类里有指针，则拷贝构造函数需要考究，如果指针只是单纯地赋值，则很有可能会造成多个对象指向同一块内存，所以释放空间时可能造成doube free的问题，所以应该拷贝一个new的空间

10. 一般拷贝构造函数和析构函数以及拷贝赋值运算符是一个整体，不会单独出现（三五法则）

更新：五中额外增加两个：移动构造函数，移动赋值运算符

一般来说，如果类定义了任何一个拷贝操作，它就应该定义所有五个操作。

11. 如果不想让一个类能拷贝，如iostream类不能被拷贝（为了避免多个对象写入或者读取相同的IO缓冲），则需要在拷贝函数后加=delete关键字声明🤧

12. =default只能用于默认构造函数和拷贝控制

而=delete可以用于任意函数(除了析构函数），通过delete编译器知道一个函数是可以删除的，禁止使用该函数

13. 如果类存在成员不能够默认构造，拷贝，复制或者销毁，则该类对应的成员函数将被定义为删除的（不能默认构造则构造函数为删除的，其他类似）

14. 具有引用成员或者无法默认构造的const成员的类，编译器不会为其合成默认构造函数

15. 同样的，如果一个类有const成员，则不能使用默认的拷贝构造函数（默认构造函数是一一赋值，const成员不能被随便改变）

16. 声明但不定义一个成员是合法的，但是试图访问一个未定义的成员将导致链接错误。

编译生成的.o文件中存着所有对象的定义，对象不存在则链接会出错。

17. 行为像值的类和行为像指针的类，一般行为像指针的类会用到shared_ptr（unique_ptr）

18. 定义行为类似指针的类一般会使用shared_ptr，但也可以自己定义，但是需要考虑到很多问题，见习题13.27

19. 编写swap函数时，类内部应该实现swap，每个swap调用都应该是类内部的swap，而不是std::swap

这样写的好处是**可以避免外部不必要的拷贝**，标准库的swap两个类可能会进行多次拷贝

20. 拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要完成的工作，在这种情况下，公共的工作应该放在private的工具函数中完成

且**在设计拷贝构造运算符时应该注意到自赋值的正确性**（自己本身给自己赋值）

21. 某一些标准类库定义了移动构造函数，移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象，避免了无效拷贝，提高效率

且移动后源对象仍然保持一个有效的可析构的状态

22. 标准库的move函数定义在utility头文件中

move一个对象会直接调用该对象的移动构造函数，使用标准库move时，应该使用std::move而不是用using
```C++
for(size_t i = 0; i != size(); ++i)
    alloc.construct(dest++, std::move(*elem++));
// construct传入的第二个参数是标准库的move函数
// *elem是string类型，所以会调用string的移动构造函数
```
23. 使用移动而不是拷贝的另一个原因源于IO类或unique_ptr的这样的类。

这些类都包含不能被共享的资源（如指针或者IO缓冲）。因此，**这些类型的对象不能拷贝，但是可以移动**

24. 对于右值的理解：没有名称的就是右值

比如常量和临时对象，都是右值

```C++
int a = 1, b = 2;
a + b = 4; // compile error

string s1("hello"), s2("world");
s1 + s2 = s2; // 编译竟然通过
string() = "World"; // 临时对象竟然也可以(是为了维持向后兼容性，因为在旧标准中无法阻止，新标准下最好不要这么写
```

一般函数的非引用返回都是右值

25. 左值引用必须绑定到一个对象上，与左值引用相反，右值引用&&直接绑定到右值表达式（不能直接绑定到某一个变量上）上

左值有持久的状态，而右值要么是字面常量，要么是临时对象。**右值引用的重要性质：只能绑定到一个将要销毁的对象**✨

由于右值引用只能绑定到临时的对象，可知：
* 所引用的对象将要被销毁
* 该对象没有其他用户

这意味着使用右值引用的代码可以自由接管所引用对象的资源📙

> ***理解右值引用设计初衷，看下面的代码段：***
> *void printV(string s);*
> *printV(string("hello world!"));*
> 
> printV函数接受的是一个左值变量
> 在调用时首先创建一个临时变量字符串"hello world!"，这是一个右值
> 然后通过string的拷贝构造函数创建一个左值形参，并传入函数
> 而String("hello world!")只是一个临时变量，被拷贝完了就没有用了
> 如果能够直接使用临时对象（即右值）已经申请的资源
> 既能节省资源，又能节省资源申请和释放的时间。
> 
> *改为直接右值捕捉*
> *void printV(string &&s);*

26. std::move(x) 表示有一个左值x，但我们希望像一个右值一样处理它

这意味着，除了对其赋值或者销毁，我们将不能对它进行任何其他操作。

27. 移动构造函数

去偷右值参数对象的空间（有点类似于浅拷贝，而拷贝构造函数是深拷贝）

可以理解成把新对象的指针指向右值参数对象的资源

![移动构造函数说明](../assets/ch13.png)

移动构造函数需要确保移后源对象处于这样一个状态：销毁它是无害的。即把图中x的指针打断（设为nullptr）

特别的是，一旦资源完成移动，源对象必须不再指向被移动的**资源**，这些资源所有权已经归属新创建的对象。

28. 由于移动操作不分配任何资源，**因此移动操作通常不应该抛出任何异常，应该是noexcept的**（这称为异常安全）

因为如果移动到一半抛出了一个异常，则旧空间中的源元素已经被改变了。

如果是拷贝构造函数，则源元素还存在，可以释放了新元素之后再拷贝。
```C++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
    ....
}
```

noexcept关键字实际上通知编译器我们这个函数应该不抛出异常，如果标准库认为移动我们的类对象可能有异常，则标准库会做一些额外工作。

29. 从一个对象移动数据并不会销毁此对象，但是在编写一个移动操作时，必须保证移后源对象进入一个可析构的状态，但是用户不能对其值进行任何假设

30. 如果一个类定义了自己的移动构造函数、移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。

**如果类成员定义了自己的拷贝控制成员（拷贝构造函数，拷贝赋值运算符，析构函数）则合成的移动构造函数和移动赋值运算符会被编译器定义为删除的。**

在这种情况下，没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使试图通过调用move来移动，右值引用&&会被自动转换成const &（即没有移动构造函数，右值也会被拷贝）

31. 某一些左值是局部变量，和临时对象一样，生命周期也很短，能不能也移动而不是拷贝呢？C++11为了解决这个问题，提供了std::move()方法来将左值转换为右值，从而方便应用移动语义

32. 类似于构造函数和赋值运算符，函数也能定义为拷贝和移动版本。

如标准库的string类型，定义了以下两个版本的push_back():
```C++
void push_back(const X&);
void push_back(X&&);
```

一般来说，当希望从实参“窃取”数据时，通常传递一个右值引用，为了到达这一目的，实参不能是const的。

类似的，从一个对象进行拷贝的操作不应该改变该对象，因此，通常声明是const X&的。

```C++
void MyStr::push_back(string && s)
{
    chk_n_alloc();
    alloc.construct(first_free+, std::move(s)); // std::move声明调用string的移动构造函数
}
```

33. 类似const限定符，引用限定符必须同时出现在函数的声明和定义中。（记得：static变量必须同时出现在函数的声明和定义中）

引用限定符解决的问题:

```C++
std::string s1("hello"), s2("world");
s1 + s2 = s2; // 编译竟然通过
string() = "World"; // 临时对象竟然也可以(是为了维持向后兼容性，因为在旧标准中无法阻止，新标准下最好不要这么写
```

如果const和引用限定符同时出现，则引用限定符必须跟在const后

```C++
class Foo
{
public:
    Foo& operator=(const Foo &) &; // 只能向可修改的左值赋值
    Foo someMem() const &; // 返回为const类型且只能用于左值
    Foo anotherMem() const &&; // 返回为const且只能用于右值
}
```

34. 引用限定符也可以区分重载版本
```C++

```

如果我们定义了2个或2个以上具有相同名字和相同参数列表的成员函数，旧必须对所有这些函数加上引用限定符